import java.awt.Colorimport java.awt.Dimensionimport java.awt.Graphicsimport java.awt.Graphics2Dimport java.awt.image.BufferedImageimport java.io.Fileimport java.io.OutputStreamimport javax.imageio.ImageIOimport javax.swing.JComponentimport javax.swing.JFrameimport javax.swing.JPaneldata class TeletextCharKey(val code: Int, val colorIndex: Int)fun getTeletextFont(smol: Boolean = false): TeletextFont = TeletextFont(if (smol) "gfx/font-smol.png" else "gfx/font.png")class TeletextFont(pngFile: String) {    val colors = mutableListOf<Color>()    val chars = mutableMapOf<TeletextCharKey, BufferedImage>()    val charW: Int    val charH: Int    init {        val img = ImageIO.read(File(pngFile))        for (y in img.height-1-7..img.height-1) {            colors.add(Color(img.getRGB(img.width-1,y)))        }        val colunmXs = mutableListOf<Int>()        val rowYs = mutableListOf<Int>()        var lastRgb = img.getRGB(0, 0)        var lastW = 1        for (x in 0 until img.width) {            val rgb = img.getRGB(x, 0)            if (rgb and 0xffffff == 0) continue            if (rgb != lastRgb) {                colunmXs.add(x)                lastW = 1            } else {                lastW++            }            lastRgb = rgb        }        lastRgb = img.getRGB(0, 0)        var lastH = 1        for (y in 0 until img.height) {            val rgb = img.getRGB(0, y)            if (rgb and 0xffffff == 0) continue            if (rgb != lastRgb) {                rowYs.add(y)                lastRgb = rgb                lastH = 1            } else {                lastH++            }        }        // println("char size: $lastW * $lastH")        charW = lastW        charH = lastH        rowYs.forEachIndexed { yIndex, y ->            colunmXs.forEachIndexed { xIndex, x ->                val code = 0x20 + yIndex * 0x10 + xIndex                val charImages = colors.map { BufferedImage(charW, charH, BufferedImage.TYPE_INT_ARGB) }                var charGs = charImages.map { img -> img.createGraphics() }                for (charX in 0 until charW) {                    for (charY in 0 until charH) {                        //println("get char code %02x - %02d, %02d + %02d, %02d".format(code, x, y, charX, charY))                        val white = img.getRGB(x + charX, y + charY) and 0xffffff == 0xffffff                        if (!white) continue                        colors.forEachIndexed { colorIndex, color ->                            charGs[colorIndex].color = color                            charGs[colorIndex].fillRect(charX, charY, 1, 1)                        }                    }                }                colors.forEachIndexed { colorIndex, color ->                    chars[TeletextCharKey(code, colorIndex)] = charImages[colorIndex]                }            }        }    }    fun renderTeletextPackets(g: Graphics2D, buf: ByteArray, elapsed: Double? = null) {        val raw = buf.size % PACKET_LEN == 0        val stride = if (raw) PACKET_LEN else PAGE_COLS        var lines = buf.size / stride        var pos = buf.size - stride        while (pos >= 0) {            var linePos = pos            pos -= stride            val y: Int            if (raw) {                val b0 = unham(buf[linePos++].toInt())                val b1 = unham(buf[linePos++].toInt())                val mpag = (b1 shl 4) or b0                val mag = (mpag and 0b00000111)                val adr = (mpag and 0b11111000) shr 3                y = adr * charH                // println("render line - mpag %02x %02x = mag %d adr %2d".format(b0, b1, mag, adr))            } else {                lines--                y = lines * charH            }            /*            00 80 Nothing          10 90 Nothing            01 81 Alpha Red        11 91 Graphic Red            02 82 Alpha Green      12 92 Graphic Green            03 83 Alpha Yellow     13 93 Graphic Yellow            04 84 Alpha Blue       14 94 Graphic Blue            05 85 Alpha Magenta    15 95 Graphic Magenta            06 86 Alpha Cyan       16 96 Graphic Cyan            07 87 Alpha White *    17 97 Graphic White            08 88 Flash            18 98 Conceal Display            09 89 Steady *         19 99 Contiguous Graphics *            0A 8A Nothing          1A 9A Separated Graphics            0B 8B Nothing          1B 9B Nothing            0C 8C Normal Height *  1C 9C Black Background *            0D 8D Double height    1D 9D New Background            0E 8E Nothing          1E 9E Hold Graphics            0F 8F Nothing          1F 9F Release Graphics *            * every line starts with these options <-- WTF does that mean             */            var backgroundColorIndex = 0            var foregroundColorIndex = colors.size-1            var gfxMode = false            var doubleHeight = false            var holdGfx = false            var lastGfxChar = 0x20            var nextForegroundColorIndex = foregroundColorIndex            var skipChars = if (raw && y == 0) 8 else 0            var blink = false            var splitGraphics = false            for (column in 0 until 40) {                val x = column * charW                val b = buf[linePos++]                var code = b.toInt() and 0x7f                if (y == 0 && column < 8) {                    code ="  P100      "[column].code                    skipChars--                } else if (skipChars-- > 0) {                    code = 0x2e                }                var drawChar = false                when (code) {                    0x00 -> { gfxMode = false; nextForegroundColorIndex = 0 }                    0x01 -> { gfxMode = false; nextForegroundColorIndex = 1 }                    0x02 -> { gfxMode = false; nextForegroundColorIndex = 2 }                    0x03 -> { gfxMode = false; nextForegroundColorIndex = 3 }                    0x04 -> { gfxMode = false; nextForegroundColorIndex = 4 }                    0x05 -> { gfxMode = false; nextForegroundColorIndex = 5 }                    0x06 -> { gfxMode = false; nextForegroundColorIndex = 6 }                    0x07 -> { gfxMode = false; nextForegroundColorIndex = 7 }                    0x08 -> blink = true                    0x09 -> blink = false                    0x10 -> { gfxMode = true;  nextForegroundColorIndex = 0 }                    0x11 -> { gfxMode = true;  nextForegroundColorIndex = 1 }                    0x12 -> { gfxMode = true;  nextForegroundColorIndex = 2 }                    0x13 -> { gfxMode = true;  nextForegroundColorIndex = 3 }                    0x14 -> { gfxMode = true;  nextForegroundColorIndex = 4 }                    0x15 -> { gfxMode = true;  nextForegroundColorIndex = 5 }                    0x16 -> { gfxMode = true;  nextForegroundColorIndex = 6 }                    0x17 -> { gfxMode = true;  nextForegroundColorIndex = 7 }                    0x1d -> backgroundColorIndex = foregroundColorIndex                    0x1c -> backgroundColorIndex = 0                    0x19 -> splitGraphics = false                    0x1a -> splitGraphics = true                    0x0c -> doubleHeight = false                    0x0d -> doubleHeight = true                    0x1e -> holdGfx = true                    0x1f -> holdGfx = false                    else -> drawChar = true                }                val useForeground: Int                if (holdGfx && !drawChar && gfxMode) {                    drawChar = true                    code = lastGfxChar                }                useForeground = foregroundColorIndex                // blinky                if (blink && elapsed != null) {                    if (elapsed % 1.0 < 0.5) drawChar = false                }                val height = if (doubleHeight) charH * 2 else charH                g.color = colors[backgroundColorIndex]                // can be intentional: if (foregroundColorIndex == 0 && backgroundColorIndex == 0) g.color = Color.GRAY                g.fillRect(x, y, charW, height)                if (drawChar) {                    if (gfxMode) {                        lastGfxChar = code                        code += 0x60                    }                    chars[TeletextCharKey(code, useForeground)]?.let { char ->                        g.drawImage(char, x, y, charW, height, null)                    }                    // fallback: mark blinky characters if no current time is available                    if (blink && elapsed == null) {                        g.color = Color.WHITE                        val blinkPadX = 4                        val blinkPadY = 6                        g.drawLine(x+blinkPadX,         y+blinkPadY, x+charW-1-blinkPadX, y+charH-1-blinkPadY)                        g.drawLine(x+charW-1-blinkPadX, y+blinkPadY, x+blinkPadX, y+charH-1-blinkPadY)                        g.drawLine(x+blinkPadX,         y+charH/2, x+charW-1-blinkPadX, y+charH/2)                    }                    if (splitGraphics) {                        g.color = colors[backgroundColorIndex]                        val gridThick = 2                        listOf(0, charW/2-gridThick+1, charW-gridThick).forEach { charX -> g.fillRect(x+charX, y, gridThick, height) }                        listOf(0, height/3-gridThick, height*2/3-gridThick+1, height-gridThick).forEach { charY -> g.fillRect(x, y+charY, charW, gridThick) }                    }                }                foregroundColorIndex = nextForegroundColorIndex            }        }    }    fun createImage(w: Int, h: Int) = BufferedImage(charW*w, charH*h, BufferedImage.TYPE_INT_RGB)    override fun toString() = "TeletextFont($charW*$charH)"}open class ImagePanel(var image: BufferedImage, val scale: Int = 1) : JPanel() {    private var g : Graphics2D? = null    override fun paintComponent(g: Graphics) {        super.paintComponent(g)        val offX = if (border != null) border.getBorderInsets(this).left - border.getBorderInsets(this).right else 0        val offY = if (border != null) border.getBorderInsets(this).top - border.getBorderInsets(this).bottom else 0        val x = (width-image.width*scale)/2 + offX/2        val y = (height-image.height*scale)/2 + offY/2        g.drawImage(image, x, y, image.width*scale, image.height*scale, null)    }    override fun getPreferredSize(): Dimension {        return Dimension(            image.width*scale  + (border?.getBorderInsets(this)?.left ?: 0) + (border?.getBorderInsets(this)?.right ?: 0),            image.height*scale + (border?.getBorderInsets(this)?.top  ?: 0) + (border?.getBorderInsets(this)?.bottom ?: 0))    }    fun getImageGraphics() : Graphics2D {        if (g == null) {            g = image.createGraphics()        }        return g!!    }}class PaintListener: JPanel() {    val start = System.currentTimeMillis()    val paintEvents = mutableListOf<Double>()    init {        preferredSize = Dimension(400, 20)    }    var lastElapsed = 0.0    fun onPaint() {        val elapsed = ((System.currentTimeMillis() - start) / 3000.0) % 1.0        if (elapsed < lastElapsed) paintEvents.clear()        paintEvents += elapsed        lastElapsed = elapsed        repaint()    }    override fun paintComponent(g: Graphics) {        super.paintComponent(g)        g.color = Color.WHITE        g.fillRect(0, 0, width, height)        g.color = Color.DARK_GRAY        paintEvents.forEach { T ->            val x = lerp(T, 5.0, width.toDouble()-5.0).toInt()            g.drawLine(x, 0, x, height-1)        }    }}class TeletextDisplayPanel(font: TeletextFont) : ImagePanel(font.createImage(PAGE_COLS, PAGE_ROWS)), BufRenderer {    var networkSink: NetworkConnection? = null    var outputSink: OutputStream? = null    var buf: ByteArray? = null    val start = System.currentTimeMillis()    var paintListener: PaintListener? = null    var font = font        set(value) {            field = value            super.image = font.createImage(PAGE_COLS, PAGE_ROWS)            repaint()        }    override fun render(buf: ByteArray) {        this.buf = buf        networkSink?.let { it.send(buf) }        outputSink?.let { it.write(buf) }        repaint()    }    override fun paintComponent(g: Graphics) {        val elapsed = (System.currentTimeMillis() - start)/1000.0        this.buf?.let { font.renderTeletextPackets(this.image.createGraphics(), it, elapsed) }        paintListener?.onPaint()        super.paintComponent(g)    }    override fun toString(): String = "display"}fun showInFrame(title: String, comp : JComponent): JFrame {    var frame = JFrame(title)    frame.defaultCloseOperation = JFrame.EXIT_ON_CLOSE    frame.contentPane = comp    frame.pack()    frame.setLocationRelativeTo(null)    frame.isVisible = true    return frame}